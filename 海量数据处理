本文主要参考这个[链接](https://blog.csdn.net/v_july_v/article/details/7382693)
### 一、海量数据处理问题  
海量数据的处理会带来时间和空间上的两个问题：  
1. 在时间上，由于数据量太大用普通方法导致在短时间内无法求解，而有的应用要求实时性（比如搜索）  
2. 在空间上，由于数据量太大导致无法将数据装载到内存中，无法完成计算。 
 
针对时间和空间的问题，解决方案如下：  
1. 在时间上，设计巧妙的算法配合合适的数据结构，比如Bloom filter/Hash/bit-map/堆排/数据库或倒排索引/trie树等。  
2. 在空间上，利用分而治之的思想，将原始海量数据文件（利用hash算法）映射成多个小文件，而后各个击破。

### 二、基本数据结构hash、map、set  
数据的容器一般分为以下两种： 
1. 序列化容器,包括list，queue，stack，heap  
2. 关联式容器，基本的有set(key和value相同)、map（映射表，key-value对）、hashtable（散列表，查找复杂度为O(1)）。
其中set和map的底层实现是RB-Tree，hashtable是根据散列函数映射位置的数组。hashmap和hashset是基于hashtable实现的。  

### 三、解决方案  

分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序  

- 例题：海量日志数据，提取出某日访问百度次数最多的那个IP。  
- 思路
    1. IP地址为32位，总共有2^32=4G中情况，无法同时加载到内存中处理。
    2. 考虑使用分而治之的思想，首先将4G种不同情况的IP通过hash函数mod(1024)映射成2^14=4M种情况的小文件中。
    3. 在每个小文件中利用hash_map统计IP出现的次数，其key为IP，value为出现频次。
    4. 在每个小文件中根据value值利用堆排序(大根堆)选择出该文件中出现频次最高的IP
    5. 在1024个小文件出现频次最高的IP中挑选value值最大的IP（依然可以利用堆排序完成）即为所求。  
- 例题：寻找热门查询，300万个查询字符串中统计最热门的10个查询    
搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。
假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。
一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G
- 思路  
假设300万(3M)条记录都是最长查询串（255byte=1k/4），那么消耗内存为0.75G，1G内存完全够用，不需要做分而治之，直接做hashmap统计，
然后就是一个标准的TopK问题了。  
    1. hashmap统计：维护一个Key为Query字串，Value为该Query出现次数的HashTable，
    即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，
    那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。
    最终我们在O(N)的时间复杂度内用Hash表完成了统计
    2. 堆排序查找Top10：根据TopK问题的分析，复杂度为NO(logK)，于是总的时间复杂度为：O(N)+NO(logk)


