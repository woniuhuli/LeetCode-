本文主要参考这个[链接](https://blog.csdn.net/baidu_28312631/article/details/47418773)    

###1、引题

- 最长公共子序列（LCS）问题。  
给出两个字符串，求出这样的一个最长的公共子序列的长度：子序列中的每个字符都能在
两个原串中找到， 而且每个字符的先后顺序和原串中的先后顺序一致。  
- 解题思路  
设输入的两个串为s1,s2, 设MaxLen(i,j)表示:s1的左边i个字符形成的子串，与s2左边的j个字符形成的子串的最长公共子序列的长度(i,j从0 开始算）。
则有初始值Maxlen(n,0)=0 Maxlen(0,m) = 0。题目即求MaxLen(len(s1),len(s2))。  
由题意知求Maxlen(i,j)以下递推方式:
  ```python
  if s1[i-1] == s2[j-1]:
    Maxlen(i,j) = Maxlen(i-1,j-1)+1
  else:
    Maxlen(i,j) = max(Maxlen(i,j-1),Maxlen(i-1,j))
  ```
  由以上分析可以写出代码
  ```python
  def LCS(s1,s2):
      length1 = len(s1)
      length2 = len(s2)
      Maxlen = [[0 for _ in range(length2+1)] for __ in range(length1+1)]
      for i in range(1,length1+1):
          for j in range(1,length2+1):
              if(s1[i-1] == s2[j-1]):
                  Maxlen[i][j] = Maxlen[i-1][j-1]+1
              else:
                  Maxlen[i][j] = max(Maxlen[i][j-1],Maxlen[i-1][j])
      return Maxlen[length1][length2]
   ```
- 最长上升子序列问题  
 一个数的序列ai，当a1 < a2 < ... < aS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ..., aN)，
 我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 <= i1 < i2 < ... < iK <= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)， 
 有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8).

- 解题思路  
1. 找最优子问题  
 “求序列的前n个元素的最长上升子序列的长度”是个子问题，但这样分解子问题，不具有“无后效性”，
 因为假设F(n) = x,但可能有多个序列满足F(n) = x。有的序列的最后一个元素比 an+1小，则加上an+1就能形成更长上 升子序列；
 有的序列最后一个元素不比an+1小……以后的事情受如何达到状态n的影响，不符合“无后效性” ，因此我们必须换一种思路来解决此问题。  
 “求以ak（k=1, 2, 3…N）为终点的最长上升子序列的长度”，一个上升子序列中最右边的那个数，称为该子序列的 “终点”。
 虽然这个子问题和原问题形式上并不完全一样，但是只要这N个子问题都解决了，那么这N个子问题的解中， 最大的那个就是整个问题的解。  
 2. 确定状态  
 子问题只和一个变量—— 数字的位置相关。因此序列中数的位置k就是“状态”，
 而状态 k 对应的“值”，就是以ak做为“终点”的最长上升子序列的长度。 状态一共有N个。  
 3. 找出状态转移方程  
 maxLen (k)表示以ak做为“终点”的最长上升子序列的长度,那么初始状态为maxLen(0) = 1。  
 转态转移方程为：maxLen (k) = max { maxLen (i)：1<=i < k 且 ai < ak且 k≠1 } + 1  若找不到这样的i,则maxLen(k) = 1  
 4. 代码
 每次根据前k-1个转态来更新当前转态。  
    ```python
    def MAL(a):
        length = len(a)
        MaxLen = [1 for _ in range(length)]
        for i in range(1,length):
            for j in range(i):
                if a[j] < a[i]:
                    MaxLen[i] = max(MaxLen[i],MaxLen[j]+1)
        return max(MaxLen)
    ```
    
### 2、动态规划
由上面两个例子，可以看出能够用动态规划来求解的问题具有以下特点：  
1. 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。
2. 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，
和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。也即在做状态递推时，当前最优状态可以由之前状态的结果明确唯一确定。  

在利用动态规划解题时，可以遵循以下步骤：  
1. 将原问题分解为子问题  
把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决。子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。  
2. 确定状态  
在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。比如最长上升子序列中的MaxLen(i)
一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。
所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。  
3. 确定一些初始状态（边界状态）的值  
比如最长公共子序列问题中的MaxLen(n,0) = 0和MaxLen(0,m)=0，以及最长上升子序列问题中的MaxLen(0)=1  
4. 确定状态转移方程  
 定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。
 状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。
 
### 3、更多例子
- 最大公共子串问题  
计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符不区分大小写。这里的最大公共字串要求的字串是连续的。  
- 思路  
按照上述总结的动态规划求解步骤，本题可以如下求解：  
1. 将原问题分解为子问题  
该最优问题的子问题可以为：以s1[i] 和s2[j]为终点的最长公共子串，记为MaxLen(i,j),如果求出了所有子问题的解，那么该问题的最优解为max(MaxLen)
2. 确定转态  
状态即为MaxLen(i，j)，子问题的最优解  
3. 确定初始值  
MaxLen(n,0) = 0;MaxLen(0,m) = 0
4. 确定状态转移方程  
由公共子串的定义知，if s1[i] == s2[j] MaxLen(i,j) = MaxLen(i-1,j-1) else MaxLen(i,j) = 0
5. 代码实现如下： 
    ```python
    def LCS(s1,s2):
       length1 = len(s1)
       length2 = len(s2)
       MaxLen = [[0 for _ in range(length2+1)] for __ in range(length1+1)]
       for i in range(1,length1+1):
           for j in range(1,length2+1):
               if s1[i-1].lower() == s2[j-1].lower():
                   MaxLen[i][j] = MaxLen[i-1][j-1]+1
               else:
                   MaxLen[i][j] = 0
       return max([max(a) for a in MaxLen])
    ```